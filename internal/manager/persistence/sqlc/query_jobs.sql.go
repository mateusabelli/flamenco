// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query_jobs.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"strings"
	"time"
)

const addWorkerToJobBlocklist = `-- name: AddWorkerToJobBlocklist :exec
INSERT INTO job_blocks (created_at, job_id, worker_id, task_type)
VALUES (?1, ?2, ?3, ?4)
ON CONFLICT DO NOTHING
`

type AddWorkerToJobBlocklistParams struct {
	CreatedAt time.Time
	JobID     int64
	WorkerID  int64
	TaskType  string
}

// Add a worker to a job's blocklist.
func (q *Queries) AddWorkerToJobBlocklist(ctx context.Context, arg AddWorkerToJobBlocklistParams) error {
	_, err := q.db.ExecContext(ctx, addWorkerToJobBlocklist,
		arg.CreatedAt,
		arg.JobID,
		arg.WorkerID,
		arg.TaskType,
	)
	return err
}

const addWorkerToTaskFailedList = `-- name: AddWorkerToTaskFailedList :exec
INSERT INTO task_failures (created_at, task_id, worker_id)
VALUES (?1, ?2, ?3)
ON CONFLICT DO NOTHING
`

type AddWorkerToTaskFailedListParams struct {
	CreatedAt time.Time
	TaskID    int64
	WorkerID  int64
}

func (q *Queries) AddWorkerToTaskFailedList(ctx context.Context, arg AddWorkerToTaskFailedListParams) error {
	_, err := q.db.ExecContext(ctx, addWorkerToTaskFailedList, arg.CreatedAt, arg.TaskID, arg.WorkerID)
	return err
}

const clearFailureListOfJob = `-- name: ClearFailureListOfJob :exec
DELETE FROM task_failures
WHERE task_id in (SELECT id FROM tasks WHERE job_id=?1)
`

// SQLite doesn't support JOIN in DELETE queries, so use a sub-query instead.
func (q *Queries) ClearFailureListOfJob(ctx context.Context, jobID int64) error {
	_, err := q.db.ExecContext(ctx, clearFailureListOfJob, jobID)
	return err
}

const clearFailureListOfTask = `-- name: ClearFailureListOfTask :exec
DELETE FROM task_failures WHERE task_id=?1
`

func (q *Queries) ClearFailureListOfTask(ctx context.Context, taskID int64) error {
	_, err := q.db.ExecContext(ctx, clearFailureListOfTask, taskID)
	return err
}

const clearJobBlocklist = `-- name: ClearJobBlocklist :exec
DELETE FROM job_blocks
WHERE job_id in (SELECT jobs.id FROM jobs WHERE jobs.uuid=?1)
`

func (q *Queries) ClearJobBlocklist(ctx context.Context, jobuuid string) error {
	_, err := q.db.ExecContext(ctx, clearJobBlocklist, jobuuid)
	return err
}

const countTaskFailuresOfWorker = `-- name: CountTaskFailuresOfWorker :one
SELECT count(TF.task_id) FROM task_failures TF
INNER JOIN tasks T ON TF.task_id = T.id
WHERE
    TF.worker_id = ?1
AND T.job_id = ?2
AND T.type = ?3
`

type CountTaskFailuresOfWorkerParams struct {
	WorkerID int64
	JobID    int64
	TaskType string
}

func (q *Queries) CountTaskFailuresOfWorker(ctx context.Context, arg CountTaskFailuresOfWorkerParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTaskFailuresOfWorker, arg.WorkerID, arg.JobID, arg.TaskType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWorkersFailingTask = `-- name: CountWorkersFailingTask :one
SELECT count(*) as num_failed FROM task_failures
WHERE task_id=?1
`

// Count how many workers have failed a given task.
func (q *Queries) CountWorkersFailingTask(ctx context.Context, taskID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWorkersFailingTask, taskID)
	var num_failed int64
	err := row.Scan(&num_failed)
	return num_failed, err
}

const createJob = `-- name: CreateJob :execlastid
INSERT INTO jobs (
  created_at,
  updated_at,
  uuid,
  name,
  job_type,
  priority,
  status,
  activity,
  settings,
  metadata,
  storage_shaman_checkout_id,
  worker_tag_id
)
VALUES (
  ?1,
  ?1,
  ?2,
  ?3,
  ?4,
  ?5,
  ?6,
  ?7,
  ?8,
  ?9,
  ?10,
  ?11
)
`

type CreateJobParams struct {
	CreatedAt               time.Time
	UUID                    string
	Name                    string
	JobType                 string
	Priority                int64
	Status                  string
	Activity                string
	Settings                json.RawMessage
	Metadata                json.RawMessage
	StorageShamanCheckoutID string
	WorkerTagID             sql.NullInt64
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createJob,
		arg.CreatedAt,
		arg.UUID,
		arg.Name,
		arg.JobType,
		arg.Priority,
		arg.Status,
		arg.Activity,
		arg.Settings,
		arg.Metadata,
		arg.StorageShamanCheckoutID,
		arg.WorkerTagID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createTask = `-- name: CreateTask :execlastid
INSERT INTO tasks (
  created_at,
  updated_at,
  uuid,
  name,
  type,
  job_id,
  index_in_job,
  priority,
  status,
  commands
) VALUES (
  ?1,
  ?1,
  ?2,
  ?3,
  ?4,
  ?5,
  ?6,
  ?7,
  ?8,
  ?9
)
`

type CreateTaskParams struct {
	CreatedAt  time.Time
	UUID       string
	Name       string
	Type       string
	JobID      int64
	IndexInJob int64
	Priority   int64
	Status     string
	Commands   json.RawMessage
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createTask,
		arg.CreatedAt,
		arg.UUID,
		arg.Name,
		arg.Type,
		arg.JobID,
		arg.IndexInJob,
		arg.Priority,
		arg.Status,
		arg.Commands,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs WHERE uuid = ?
`

func (q *Queries) DeleteJob(ctx context.Context, uuid string) error {
	_, err := q.db.ExecContext(ctx, deleteJob, uuid)
	return err
}

const fetchJob = `-- name: FetchJob :one
SELECT id, created_at, updated_at, uuid, name, job_type, priority, status, activity, settings, metadata, delete_requested_at, storage_shaman_checkout_id, worker_tag_id FROM jobs
WHERE uuid = ? LIMIT 1
`

// Fetch a job by its UUID.
func (q *Queries) FetchJob(ctx context.Context, uuid string) (Job, error) {
	row := q.db.QueryRowContext(ctx, fetchJob, uuid)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UUID,
		&i.Name,
		&i.JobType,
		&i.Priority,
		&i.Status,
		&i.Activity,
		&i.Settings,
		&i.Metadata,
		&i.DeleteRequestedAt,
		&i.StorageShamanCheckoutID,
		&i.WorkerTagID,
	)
	return i, err
}

const fetchJobBlocklist = `-- name: FetchJobBlocklist :many
SELECT job_blocks.id, job_blocks.task_type, workers.uuid as workeruuid, workers.name as worker_name
FROM job_blocks
INNER JOIN jobs ON jobs.id = job_blocks.job_id
INNER JOIN workers on workers.id = job_blocks.worker_id
WHERE jobs.uuid = ?1
ORDER BY workers.name
`

type FetchJobBlocklistRow struct {
	ID         int64
	TaskType   string
	WorkerUUID string
	WorkerName string
}

// Fetch the blocklist of a specific job.
func (q *Queries) FetchJobBlocklist(ctx context.Context, jobuuid string) ([]FetchJobBlocklistRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchJobBlocklist, jobuuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchJobBlocklistRow
	for rows.Next() {
		var i FetchJobBlocklistRow
		if err := rows.Scan(
			&i.ID,
			&i.TaskType,
			&i.WorkerUUID,
			&i.WorkerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchJobByID = `-- name: FetchJobByID :one
SELECT id, created_at, updated_at, uuid, name, job_type, priority, status, activity, settings, metadata, delete_requested_at, storage_shaman_checkout_id, worker_tag_id FROM jobs
WHERE id = ? LIMIT 1
`

// Fetch a job by its numerical ID.
func (q *Queries) FetchJobByID(ctx context.Context, id int64) (Job, error) {
	row := q.db.QueryRowContext(ctx, fetchJobByID, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UUID,
		&i.Name,
		&i.JobType,
		&i.Priority,
		&i.Status,
		&i.Activity,
		&i.Settings,
		&i.Metadata,
		&i.DeleteRequestedAt,
		&i.StorageShamanCheckoutID,
		&i.WorkerTagID,
	)
	return i, err
}

const fetchJobShamanCheckoutID = `-- name: FetchJobShamanCheckoutID :one
SELECT storage_shaman_checkout_id FROM jobs WHERE uuid=?1
`

func (q *Queries) FetchJobShamanCheckoutID(ctx context.Context, uuid string) (string, error) {
	row := q.db.QueryRowContext(ctx, fetchJobShamanCheckoutID, uuid)
	var storage_shaman_checkout_id string
	err := row.Scan(&storage_shaman_checkout_id)
	return storage_shaman_checkout_id, err
}

const fetchJobUUIDsUpdatedBefore = `-- name: FetchJobUUIDsUpdatedBefore :many
SELECT uuid FROM jobs WHERE updated_at <= ?1
`

func (q *Queries) FetchJobUUIDsUpdatedBefore(ctx context.Context, updatedAtMax sql.NullTime) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, fetchJobUUIDsUpdatedBefore, updatedAtMax)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var uuid string
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchJobs = `-- name: FetchJobs :many
SELECT id, created_at, updated_at, uuid, name, job_type, priority, status, activity, settings, metadata, delete_requested_at, storage_shaman_checkout_id, worker_tag_id fRoM jobs
`

// Fetch all jobs in the database.
func (q *Queries) FetchJobs(ctx context.Context) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, fetchJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UUID,
			&i.Name,
			&i.JobType,
			&i.Priority,
			&i.Status,
			&i.Activity,
			&i.Settings,
			&i.Metadata,
			&i.DeleteRequestedAt,
			&i.StorageShamanCheckoutID,
			&i.WorkerTagID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchJobsDeletionRequested = `-- name: FetchJobsDeletionRequested :many
SELECT uuid FROM jobs
  WHERE delete_requested_at is not NULL
  ORDER BY delete_requested_at
`

func (q *Queries) FetchJobsDeletionRequested(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, fetchJobsDeletionRequested)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var uuid string
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchJobsInStatus = `-- name: FetchJobsInStatus :many
SELECT id, created_at, updated_at, uuid, name, job_type, priority, status, activity, settings, metadata, delete_requested_at, storage_shaman_checkout_id, worker_tag_id FROM jobs WHERE status IN (/*SLICE:statuses*/?)
`

func (q *Queries) FetchJobsInStatus(ctx context.Context, statuses []string) ([]Job, error) {
	query := fetchJobsInStatus
	var queryParams []interface{}
	if len(statuses) > 0 {
		for _, v := range statuses {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:statuses*/?", strings.Repeat(",?", len(statuses))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:statuses*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UUID,
			&i.Name,
			&i.JobType,
			&i.Priority,
			&i.Status,
			&i.Activity,
			&i.Settings,
			&i.Metadata,
			&i.DeleteRequestedAt,
			&i.StorageShamanCheckoutID,
			&i.WorkerTagID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTask = `-- name: FetchTask :one
SELECT tasks.id, tasks.created_at, tasks.updated_at, tasks.uuid, tasks.name, tasks.type, tasks.job_id, tasks.index_in_job, tasks.priority, tasks.status, tasks.worker_id, tasks.last_touched_at, tasks.commands, tasks.activity, jobs.UUID as jobUUID, workers.UUID as workerUUID
FROM tasks
LEFT JOIN jobs ON (tasks.job_id = jobs.id)
LEFT JOIN workers ON (tasks.worker_id = workers.id)
WHERE tasks.uuid = ?1
`

type FetchTaskRow struct {
	Task       Task
	JobUUID    sql.NullString
	WorkerUUID sql.NullString
}

func (q *Queries) FetchTask(ctx context.Context, uuid string) (FetchTaskRow, error) {
	row := q.db.QueryRowContext(ctx, fetchTask, uuid)
	var i FetchTaskRow
	err := row.Scan(
		&i.Task.ID,
		&i.Task.CreatedAt,
		&i.Task.UpdatedAt,
		&i.Task.UUID,
		&i.Task.Name,
		&i.Task.Type,
		&i.Task.JobID,
		&i.Task.IndexInJob,
		&i.Task.Priority,
		&i.Task.Status,
		&i.Task.WorkerID,
		&i.Task.LastTouchedAt,
		&i.Task.Commands,
		&i.Task.Activity,
		&i.JobUUID,
		&i.WorkerUUID,
	)
	return i, err
}

const fetchTaskFailureList = `-- name: FetchTaskFailureList :many
SELECT workers.id, workers.created_at, workers.updated_at, workers.uuid, workers.secret, workers.name, workers.address, workers.platform, workers.software, workers.status, workers.last_seen_at, workers.status_requested, workers.lazy_status_request, workers.supported_task_types, workers.deleted_at, workers.can_restart FROM workers
INNER JOIN task_failures TF on TF.worker_id=workers.id
WHERE TF.task_id=?1
`

type FetchTaskFailureListRow struct {
	Worker Worker
}

func (q *Queries) FetchTaskFailureList(ctx context.Context, taskID int64) ([]FetchTaskFailureListRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchTaskFailureList, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchTaskFailureListRow
	for rows.Next() {
		var i FetchTaskFailureListRow
		if err := rows.Scan(
			&i.Worker.ID,
			&i.Worker.CreatedAt,
			&i.Worker.UpdatedAt,
			&i.Worker.UUID,
			&i.Worker.Secret,
			&i.Worker.Name,
			&i.Worker.Address,
			&i.Worker.Platform,
			&i.Worker.Software,
			&i.Worker.Status,
			&i.Worker.LastSeenAt,
			&i.Worker.StatusRequested,
			&i.Worker.LazyStatusRequest,
			&i.Worker.SupportedTaskTypes,
			&i.Worker.DeletedAt,
			&i.Worker.CanRestart,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTaskJobUUID = `-- name: FetchTaskJobUUID :one
SELECT jobs.UUID as jobUUID
FROM tasks
LEFT JOIN jobs ON (tasks.job_id = jobs.id)
WHERE tasks.uuid = ?1
`

func (q *Queries) FetchTaskJobUUID(ctx context.Context, uuid string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, fetchTaskJobUUID, uuid)
	var jobuuid sql.NullString
	err := row.Scan(&jobuuid)
	return jobuuid, err
}

const fetchTasksOfJob = `-- name: FetchTasksOfJob :many
SELECT tasks.id, tasks.created_at, tasks.updated_at, tasks.uuid, tasks.name, tasks.type, tasks.job_id, tasks.index_in_job, tasks.priority, tasks.status, tasks.worker_id, tasks.last_touched_at, tasks.commands, tasks.activity, workers.UUID as workerUUID
FROM tasks
LEFT JOIN workers ON (tasks.worker_id = workers.id)
WHERE tasks.job_id = ?1
`

type FetchTasksOfJobRow struct {
	Task       Task
	WorkerUUID sql.NullString
}

func (q *Queries) FetchTasksOfJob(ctx context.Context, jobID int64) ([]FetchTasksOfJobRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchTasksOfJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchTasksOfJobRow
	for rows.Next() {
		var i FetchTasksOfJobRow
		if err := rows.Scan(
			&i.Task.ID,
			&i.Task.CreatedAt,
			&i.Task.UpdatedAt,
			&i.Task.UUID,
			&i.Task.Name,
			&i.Task.Type,
			&i.Task.JobID,
			&i.Task.IndexInJob,
			&i.Task.Priority,
			&i.Task.Status,
			&i.Task.WorkerID,
			&i.Task.LastTouchedAt,
			&i.Task.Commands,
			&i.Task.Activity,
			&i.WorkerUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTasksOfJobInStatus = `-- name: FetchTasksOfJobInStatus :many
SELECT tasks.id, tasks.created_at, tasks.updated_at, tasks.uuid, tasks.name, tasks.type, tasks.job_id, tasks.index_in_job, tasks.priority, tasks.status, tasks.worker_id, tasks.last_touched_at, tasks.commands, tasks.activity, workers.UUID as workerUUID
FROM tasks
LEFT JOIN workers ON (tasks.worker_id = workers.id)
WHERE tasks.job_id = ?1
  AND tasks.status in (/*SLICE:task_status*/?)
`

type FetchTasksOfJobInStatusParams struct {
	JobID      int64
	TaskStatus []string
}

type FetchTasksOfJobInStatusRow struct {
	Task       Task
	WorkerUUID sql.NullString
}

func (q *Queries) FetchTasksOfJobInStatus(ctx context.Context, arg FetchTasksOfJobInStatusParams) ([]FetchTasksOfJobInStatusRow, error) {
	query := fetchTasksOfJobInStatus
	var queryParams []interface{}
	queryParams = append(queryParams, arg.JobID)
	if len(arg.TaskStatus) > 0 {
		for _, v := range arg.TaskStatus {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:task_status*/?", strings.Repeat(",?", len(arg.TaskStatus))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:task_status*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchTasksOfJobInStatusRow
	for rows.Next() {
		var i FetchTasksOfJobInStatusRow
		if err := rows.Scan(
			&i.Task.ID,
			&i.Task.CreatedAt,
			&i.Task.UpdatedAt,
			&i.Task.UUID,
			&i.Task.Name,
			&i.Task.Type,
			&i.Task.JobID,
			&i.Task.IndexInJob,
			&i.Task.Priority,
			&i.Task.Status,
			&i.Task.WorkerID,
			&i.Task.LastTouchedAt,
			&i.Task.Commands,
			&i.Task.Activity,
			&i.WorkerUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTasksOfWorkerInStatus = `-- name: FetchTasksOfWorkerInStatus :many
SELECT tasks.id, tasks.created_at, tasks.updated_at, tasks.uuid, tasks.name, tasks.type, tasks.job_id, tasks.index_in_job, tasks.priority, tasks.status, tasks.worker_id, tasks.last_touched_at, tasks.commands, tasks.activity, jobs.UUID as jobUUID
FROM tasks
LEFT JOIN jobs ON (tasks.job_id = jobs.id)
WHERE tasks.worker_id = ?1
  AND tasks.status = ?2
`

type FetchTasksOfWorkerInStatusParams struct {
	WorkerID   sql.NullInt64
	TaskStatus string
}

type FetchTasksOfWorkerInStatusRow struct {
	Task    Task
	JobUUID sql.NullString
}

func (q *Queries) FetchTasksOfWorkerInStatus(ctx context.Context, arg FetchTasksOfWorkerInStatusParams) ([]FetchTasksOfWorkerInStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchTasksOfWorkerInStatus, arg.WorkerID, arg.TaskStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchTasksOfWorkerInStatusRow
	for rows.Next() {
		var i FetchTasksOfWorkerInStatusRow
		if err := rows.Scan(
			&i.Task.ID,
			&i.Task.CreatedAt,
			&i.Task.UpdatedAt,
			&i.Task.UUID,
			&i.Task.Name,
			&i.Task.Type,
			&i.Task.JobID,
			&i.Task.IndexInJob,
			&i.Task.Priority,
			&i.Task.Status,
			&i.Task.WorkerID,
			&i.Task.LastTouchedAt,
			&i.Task.Commands,
			&i.Task.Activity,
			&i.JobUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTasksOfWorkerInStatusOfJob = `-- name: FetchTasksOfWorkerInStatusOfJob :many
SELECT tasks.id, tasks.created_at, tasks.updated_at, tasks.uuid, tasks.name, tasks.type, tasks.job_id, tasks.index_in_job, tasks.priority, tasks.status, tasks.worker_id, tasks.last_touched_at, tasks.commands, tasks.activity
FROM tasks
WHERE tasks.worker_id = ?1
  AND tasks.job_id = ?2
  AND tasks.status = ?3
`

type FetchTasksOfWorkerInStatusOfJobParams struct {
	WorkerID   sql.NullInt64
	JobID      int64
	TaskStatus string
}

type FetchTasksOfWorkerInStatusOfJobRow struct {
	Task Task
}

func (q *Queries) FetchTasksOfWorkerInStatusOfJob(ctx context.Context, arg FetchTasksOfWorkerInStatusOfJobParams) ([]FetchTasksOfWorkerInStatusOfJobRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchTasksOfWorkerInStatusOfJob, arg.WorkerID, arg.JobID, arg.TaskStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchTasksOfWorkerInStatusOfJobRow
	for rows.Next() {
		var i FetchTasksOfWorkerInStatusOfJobRow
		if err := rows.Scan(
			&i.Task.ID,
			&i.Task.CreatedAt,
			&i.Task.UpdatedAt,
			&i.Task.UUID,
			&i.Task.Name,
			&i.Task.Type,
			&i.Task.JobID,
			&i.Task.IndexInJob,
			&i.Task.Priority,
			&i.Task.Status,
			&i.Task.WorkerID,
			&i.Task.LastTouchedAt,
			&i.Task.Commands,
			&i.Task.Activity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTimedOutTasks = `-- name: FetchTimedOutTasks :many
SELECT id, created_at, updated_at, uuid, name, type, job_id, index_in_job, priority, status, worker_id, last_touched_at, commands, activity
FROM tasks
WHERE
    status = ?1
AND last_touched_at <= ?2
`

type FetchTimedOutTasksParams struct {
	TaskStatus     string
	UntouchedSince sql.NullTime
}

func (q *Queries) FetchTimedOutTasks(ctx context.Context, arg FetchTimedOutTasksParams) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, fetchTimedOutTasks, arg.TaskStatus, arg.UntouchedSince)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UUID,
			&i.Name,
			&i.Type,
			&i.JobID,
			&i.IndexInJob,
			&i.Priority,
			&i.Status,
			&i.WorkerID,
			&i.LastTouchedAt,
			&i.Commands,
			&i.Activity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastRenderedJobUUID = `-- name: GetLastRenderedJobUUID :one
SELECT uuid FROM jobs
INNER JOIN last_rendereds LR ON jobs.id = LR.job_id
`

func (q *Queries) GetLastRenderedJobUUID(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getLastRenderedJobUUID)
	var uuid string
	err := row.Scan(&uuid)
	return uuid, err
}

const jobCountTaskStatuses = `-- name: JobCountTaskStatuses :many
SELECT status, count(*) as num_tasks FROM tasks
WHERE job_id = ?1
GROUP BY status
`

type JobCountTaskStatusesRow struct {
	Status   string
	NumTasks int64
}

// Fetch (status, num tasks in that status) rows for the given job.
func (q *Queries) JobCountTaskStatuses(ctx context.Context, jobID int64) ([]JobCountTaskStatusesRow, error) {
	rows, err := q.db.QueryContext(ctx, jobCountTaskStatuses, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobCountTaskStatusesRow
	for rows.Next() {
		var i JobCountTaskStatusesRow
		if err := rows.Scan(&i.Status, &i.NumTasks); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const jobCountTasksInStatus = `-- name: JobCountTasksInStatus :one
SELECT count(*) as num_tasks FROM tasks
WHERE job_id = ?1 AND status = ?2
`

type JobCountTasksInStatusParams struct {
	JobID      int64
	TaskStatus string
}

// Fetch number of tasks in the given status, of the given job.
func (q *Queries) JobCountTasksInStatus(ctx context.Context, arg JobCountTasksInStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, jobCountTasksInStatus, arg.JobID, arg.TaskStatus)
	var num_tasks int64
	err := row.Scan(&num_tasks)
	return num_tasks, err
}

const queryJobTaskSummaries = `-- name: QueryJobTaskSummaries :many
SELECT tasks.id, tasks.uuid, tasks.name, tasks.index_in_job, tasks.priority, tasks.status, tasks.type, tasks.updated_at
FROM tasks
LEFT JOIN jobs ON jobs.id = tasks.job_id
WHERE jobs.uuid=?1
`

type QueryJobTaskSummariesRow struct {
	ID         int64
	UUID       string
	Name       string
	IndexInJob int64
	Priority   int64
	Status     string
	Type       string
	UpdatedAt  sql.NullTime
}

func (q *Queries) QueryJobTaskSummaries(ctx context.Context, jobUuid string) ([]QueryJobTaskSummariesRow, error) {
	rows, err := q.db.QueryContext(ctx, queryJobTaskSummaries, jobUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryJobTaskSummariesRow
	for rows.Next() {
		var i QueryJobTaskSummariesRow
		if err := rows.Scan(
			&i.ID,
			&i.UUID,
			&i.Name,
			&i.IndexInJob,
			&i.Priority,
			&i.Status,
			&i.Type,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFromJobBlocklist = `-- name: RemoveFromJobBlocklist :exec
DELETE FROM job_blocks
WHERE
    job_blocks.job_id in (SELECT jobs.id FROM jobs WHERE jobs.uuid=?1)
AND job_blocks.worker_id in (SELECT workers.id FROM workers WHERE workers.uuid=?2)
AND job_blocks.task_type = ?3
`

type RemoveFromJobBlocklistParams struct {
	JobUUID    string
	WorkerUUID string
	TaskType   string
}

func (q *Queries) RemoveFromJobBlocklist(ctx context.Context, arg RemoveFromJobBlocklistParams) error {
	_, err := q.db.ExecContext(ctx, removeFromJobBlocklist, arg.JobUUID, arg.WorkerUUID, arg.TaskType)
	return err
}

const requestJobDeletion = `-- name: RequestJobDeletion :exec
UPDATE jobs SET
  updated_at = ?1,
  delete_requested_at = ?1
WHERE id = ?2
`

type RequestJobDeletionParams struct {
	Now   sql.NullTime
	JobID int64
}

func (q *Queries) RequestJobDeletion(ctx context.Context, arg RequestJobDeletionParams) error {
	_, err := q.db.ExecContext(ctx, requestJobDeletion, arg.Now, arg.JobID)
	return err
}

const requestMassJobDeletion = `-- name: RequestMassJobDeletion :exec
UPDATE jobs SET
  updated_at = ?1,
  delete_requested_at = ?1
WHERE uuid in (/*SLICE:uuids*/?)
`

type RequestMassJobDeletionParams struct {
	Now   sql.NullTime
	UUIDs []string
}

func (q *Queries) RequestMassJobDeletion(ctx context.Context, arg RequestMassJobDeletionParams) error {
	query := requestMassJobDeletion
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Now)
	if len(arg.UUIDs) > 0 {
		for _, v := range arg.UUIDs {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:uuids*/?", strings.Repeat(",?", len(arg.UUIDs))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:uuids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const saveJobPriority = `-- name: SaveJobPriority :exec
UPDATE jobs SET updated_at=?1, priority=?2 WHERE id=?3
`

type SaveJobPriorityParams struct {
	Now      sql.NullTime
	Priority int64
	ID       int64
}

func (q *Queries) SaveJobPriority(ctx context.Context, arg SaveJobPriorityParams) error {
	_, err := q.db.ExecContext(ctx, saveJobPriority, arg.Now, arg.Priority, arg.ID)
	return err
}

const saveJobStatus = `-- name: SaveJobStatus :exec
UPDATE jobs SET updated_at=?1, status=?2, activity=?3 WHERE id=?4
`

type SaveJobStatusParams struct {
	Now      sql.NullTime
	Status   string
	Activity string
	ID       int64
}

func (q *Queries) SaveJobStatus(ctx context.Context, arg SaveJobStatusParams) error {
	_, err := q.db.ExecContext(ctx, saveJobStatus,
		arg.Now,
		arg.Status,
		arg.Activity,
		arg.ID,
	)
	return err
}

const saveJobStorageInfo = `-- name: SaveJobStorageInfo :exec
UPDATE jobs SET storage_shaman_checkout_id=?1 WHERE id=?2
`

type SaveJobStorageInfoParams struct {
	StorageShamanCheckoutID string
	ID                      int64
}

func (q *Queries) SaveJobStorageInfo(ctx context.Context, arg SaveJobStorageInfoParams) error {
	_, err := q.db.ExecContext(ctx, saveJobStorageInfo, arg.StorageShamanCheckoutID, arg.ID)
	return err
}

const setLastRendered = `-- name: SetLastRendered :exec
INSERT INTO last_rendereds (id, created_at, updated_at, job_id)
VALUES (1, ?1, ?2, ?3)
ON CONFLICT DO UPDATE
  SET updated_at=?2, job_id=?3
  WHERE id=1
`

type SetLastRenderedParams struct {
	CreatedAt time.Time
	UpdatedAt sql.NullTime
	JobID     int64
}

// Set the 'last rendered' job info.
//
// Note that the use of ?2 and ?3 in the SQL is not desirable, and should be
// replaced with @updated_at and @job_id as soon as sqlc issue #3334 is fixed.
// See https://github.com/sqlc-dev/sqlc/issues/3334 for more info.
func (q *Queries) SetLastRendered(ctx context.Context, arg SetLastRenderedParams) error {
	_, err := q.db.ExecContext(ctx, setLastRendered, arg.CreatedAt, arg.UpdatedAt, arg.JobID)
	return err
}

const storeTaskDependency = `-- name: StoreTaskDependency :exec
INSERT INTO task_dependencies (task_id, dependency_id) VALUES (?1, ?2)
`

type StoreTaskDependencyParams struct {
	TaskID       int64
	DependencyID int64
}

func (q *Queries) StoreTaskDependency(ctx context.Context, arg StoreTaskDependencyParams) error {
	_, err := q.db.ExecContext(ctx, storeTaskDependency, arg.TaskID, arg.DependencyID)
	return err
}

const summarizeJobStatuses = `-- name: SummarizeJobStatuses :many
SELECT status, count(id) as status_count FROM jobs
GROUP BY status
`

type SummarizeJobStatusesRow struct {
	Status      string
	StatusCount int64
}

func (q *Queries) SummarizeJobStatuses(ctx context.Context) ([]SummarizeJobStatusesRow, error) {
	rows, err := q.db.QueryContext(ctx, summarizeJobStatuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SummarizeJobStatusesRow
	for rows.Next() {
		var i SummarizeJobStatusesRow
		if err := rows.Scan(&i.Status, &i.StatusCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const taskAssignToWorker = `-- name: TaskAssignToWorker :exec
UPDATE tasks SET
  updated_at = ?1,
  worker_id = ?2
WHERE id=?3
`

type TaskAssignToWorkerParams struct {
	UpdatedAt sql.NullTime
	WorkerID  sql.NullInt64
	ID        int64
}

func (q *Queries) TaskAssignToWorker(ctx context.Context, arg TaskAssignToWorkerParams) error {
	_, err := q.db.ExecContext(ctx, taskAssignToWorker, arg.UpdatedAt, arg.WorkerID, arg.ID)
	return err
}

const taskTouchedByWorker = `-- name: TaskTouchedByWorker :exec
UPDATE tasks SET
  updated_at = ?1,
  last_touched_at = ?2
WHERE id=?3
`

type TaskTouchedByWorkerParams struct {
	UpdatedAt     sql.NullTime
	LastTouchedAt sql.NullTime
	ID            int64
}

func (q *Queries) TaskTouchedByWorker(ctx context.Context, arg TaskTouchedByWorkerParams) error {
	_, err := q.db.ExecContext(ctx, taskTouchedByWorker, arg.UpdatedAt, arg.LastTouchedAt, arg.ID)
	return err
}

const test_CountJobs = `-- name: Test_CountJobs :one
SELECT count(*) AS count FROM jobs
`

// Count the number of jobs in the database. Only used in unit tests.
func (q *Queries) Test_CountJobs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, test_CountJobs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const test_CountTaskFailures = `-- name: Test_CountTaskFailures :one
SELECT count(*) AS count FROM task_failures
`

// Count the number of task failures in the database. Only used in unit tests.
func (q *Queries) Test_CountTaskFailures(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, test_CountTaskFailures)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const test_CountTasks = `-- name: Test_CountTasks :one
SELECT count(*) AS count FROM tasks
`

// Count the number of tasks in the database. Only used in unit tests.
func (q *Queries) Test_CountTasks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, test_CountTasks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const test_FetchJobBlocklist = `-- name: Test_FetchJobBlocklist :many
SELECT id, created_at, job_id, worker_id, task_type FROM job_blocks
`

// Fetch all job block list entries. Used only in unit tests.
func (q *Queries) Test_FetchJobBlocklist(ctx context.Context) ([]JobBlock, error) {
	rows, err := q.db.QueryContext(ctx, test_FetchJobBlocklist)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobBlock
	for rows.Next() {
		var i JobBlock
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.JobID,
			&i.WorkerID,
			&i.TaskType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const test_FetchLastRendered = `-- name: Test_FetchLastRendered :many
SELECT id, created_at, updated_at, job_id FROM last_rendereds
`

// Fetch all 'last rendered' in the database (even though there should only be
// one at most). Only used in unit tests.
func (q *Queries) Test_FetchLastRendered(ctx context.Context) ([]LastRendered, error) {
	rows, err := q.db.QueryContext(ctx, test_FetchLastRendered)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LastRendered
	for rows.Next() {
		var i LastRendered
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.JobID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const test_FetchTaskFailures = `-- name: Test_FetchTaskFailures :many
SELECT created_at, task_id, worker_id FROM task_failures
`

// Fetch all task failures in the database. Only used in unit tests.
func (q *Queries) Test_FetchTaskFailures(ctx context.Context) ([]TaskFailure, error) {
	rows, err := q.db.QueryContext(ctx, test_FetchTaskFailures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskFailure
	for rows.Next() {
		var i TaskFailure
		if err := rows.Scan(&i.CreatedAt, &i.TaskID, &i.WorkerID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJobsTaskStatuses = `-- name: UpdateJobsTaskStatuses :exec
UPDATE tasks SET
  updated_at = ?1,
  status = ?2,
  activity = ?3
WHERE job_id = ?4
`

type UpdateJobsTaskStatusesParams struct {
	UpdatedAt sql.NullTime
	Status    string
	Activity  string
	JobID     int64
}

func (q *Queries) UpdateJobsTaskStatuses(ctx context.Context, arg UpdateJobsTaskStatusesParams) error {
	_, err := q.db.ExecContext(ctx, updateJobsTaskStatuses,
		arg.UpdatedAt,
		arg.Status,
		arg.Activity,
		arg.JobID,
	)
	return err
}

const updateJobsTaskStatusesConditional = `-- name: UpdateJobsTaskStatusesConditional :exec
UPDATE tasks SET
  updated_at = ?1,
  status = ?2,
  activity = ?3
WHERE job_id = ?4 AND status in (/*SLICE:statuses_to_update*/?)
`

type UpdateJobsTaskStatusesConditionalParams struct {
	UpdatedAt        sql.NullTime
	Status           string
	Activity         string
	JobID            int64
	StatusesToUpdate []string
}

func (q *Queries) UpdateJobsTaskStatusesConditional(ctx context.Context, arg UpdateJobsTaskStatusesConditionalParams) error {
	query := updateJobsTaskStatusesConditional
	var queryParams []interface{}
	queryParams = append(queryParams, arg.UpdatedAt)
	queryParams = append(queryParams, arg.Status)
	queryParams = append(queryParams, arg.Activity)
	queryParams = append(queryParams, arg.JobID)
	if len(arg.StatusesToUpdate) > 0 {
		for _, v := range arg.StatusesToUpdate {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:statuses_to_update*/?", strings.Repeat(",?", len(arg.StatusesToUpdate))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:statuses_to_update*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const updateTask = `-- name: UpdateTask :exec
UPDATE tasks SET
  updated_at = ?1,
  name = ?2,
  type = ?3,
  priority = ?4,
  status = ?5,
  worker_id = ?6,
  last_touched_at = ?7,
  commands = ?8,
  activity = ?9
WHERE id=?10
`

type UpdateTaskParams struct {
	UpdatedAt     sql.NullTime
	Name          string
	Type          string
	Priority      int64
	Status        string
	WorkerID      sql.NullInt64
	LastTouchedAt sql.NullTime
	Commands      json.RawMessage
	Activity      string
	ID            int64
}

// Update a Task, except its id, created_at, uuid, or job_id fields.
func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.db.ExecContext(ctx, updateTask,
		arg.UpdatedAt,
		arg.Name,
		arg.Type,
		arg.Priority,
		arg.Status,
		arg.WorkerID,
		arg.LastTouchedAt,
		arg.Commands,
		arg.Activity,
		arg.ID,
	)
	return err
}

const updateTaskActivity = `-- name: UpdateTaskActivity :exec
UPDATE tasks SET
  updated_at = ?1,
  activity = ?2
WHERE id=?3
`

type UpdateTaskActivityParams struct {
	UpdatedAt sql.NullTime
	Activity  string
	ID        int64
}

func (q *Queries) UpdateTaskActivity(ctx context.Context, arg UpdateTaskActivityParams) error {
	_, err := q.db.ExecContext(ctx, updateTaskActivity, arg.UpdatedAt, arg.Activity, arg.ID)
	return err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :exec
UPDATE tasks SET
  updated_at = ?1,
  status = ?2
WHERE id=?3
`

type UpdateTaskStatusParams struct {
	UpdatedAt sql.NullTime
	Status    string
	ID        int64
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTaskStatus, arg.UpdatedAt, arg.Status, arg.ID)
	return err
}

const workersLeftToRun = `-- name: WorkersLeftToRun :many
SELECT workers.uuid FROM workers
WHERE id NOT IN (
  SELECT blocked_workers.id
  FROM workers AS blocked_workers
  INNER JOIN job_blocks JB on blocked_workers.id = JB.worker_id
  WHERE
      JB.job_id = ?1
  AND JB.task_type = ?2
)
`

type WorkersLeftToRunParams struct {
	JobID    int64
	TaskType string
}

func (q *Queries) WorkersLeftToRun(ctx context.Context, arg WorkersLeftToRunParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, workersLeftToRun, arg.JobID, arg.TaskType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var uuid string
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const workersLeftToRunWithWorkerTag = `-- name: WorkersLeftToRunWithWorkerTag :many
SELECT workers.uuid
FROM workers
INNER JOIN worker_tag_membership WTM ON workers.id = WTM.worker_id
WHERE id NOT IN (
  SELECT blocked_workers.id
  FROM workers AS blocked_workers
  INNER JOIN job_blocks JB ON blocked_workers.id = JB.worker_id
  WHERE
      JB.job_id = ?1
  AND JB.task_type = ?2
)
AND WTM.worker_tag_id = ?3
`

type WorkersLeftToRunWithWorkerTagParams struct {
	JobID       int64
	TaskType    string
	WorkerTagID int64
}

func (q *Queries) WorkersLeftToRunWithWorkerTag(ctx context.Context, arg WorkersLeftToRunWithWorkerTagParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, workersLeftToRunWithWorkerTag, arg.JobID, arg.TaskType, arg.WorkerTagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var uuid string
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
