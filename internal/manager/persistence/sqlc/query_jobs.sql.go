// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query_jobs.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"strings"
	"time"
)

const createJob = `-- name: CreateJob :exec

INSERT INTO jobs (
  created_at,
  uuid,
  name,
  job_type,
  priority,
  status,
  activity,
  settings,
  metadata,
  storage_shaman_checkout_id
)
VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )
`

type CreateJobParams struct {
	CreatedAt               time.Time
	UUID                    string
	Name                    string
	JobType                 string
	Priority                int64
	Status                  string
	Activity                string
	Settings                json.RawMessage
	Metadata                json.RawMessage
	StorageShamanCheckoutID string
}

// Jobs / Tasks queries
//
func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) error {
	_, err := q.db.ExecContext(ctx, createJob,
		arg.CreatedAt,
		arg.UUID,
		arg.Name,
		arg.JobType,
		arg.Priority,
		arg.Status,
		arg.Activity,
		arg.Settings,
		arg.Metadata,
		arg.StorageShamanCheckoutID,
	)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs WHERE uuid = ?
`

func (q *Queries) DeleteJob(ctx context.Context, uuid string) error {
	_, err := q.db.ExecContext(ctx, deleteJob, uuid)
	return err
}

const fetchJob = `-- name: FetchJob :one
SELECT id, created_at, updated_at, uuid, name, job_type, priority, status, activity, settings, metadata, delete_requested_at, storage_shaman_checkout_id, worker_tag_id FROM jobs
WHERE uuid = ? LIMIT 1
`

// Fetch a job by its UUID.
func (q *Queries) FetchJob(ctx context.Context, uuid string) (Job, error) {
	row := q.db.QueryRowContext(ctx, fetchJob, uuid)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UUID,
		&i.Name,
		&i.JobType,
		&i.Priority,
		&i.Status,
		&i.Activity,
		&i.Settings,
		&i.Metadata,
		&i.DeleteRequestedAt,
		&i.StorageShamanCheckoutID,
		&i.WorkerTagID,
	)
	return i, err
}

const fetchJobByID = `-- name: FetchJobByID :one
SELECT id, created_at, updated_at, uuid, name, job_type, priority, status, activity, settings, metadata, delete_requested_at, storage_shaman_checkout_id, worker_tag_id FROM jobs
WHERE id = ? LIMIT 1
`

// Fetch a job by its numerical ID.
func (q *Queries) FetchJobByID(ctx context.Context, id int64) (Job, error) {
	row := q.db.QueryRowContext(ctx, fetchJobByID, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UUID,
		&i.Name,
		&i.JobType,
		&i.Priority,
		&i.Status,
		&i.Activity,
		&i.Settings,
		&i.Metadata,
		&i.DeleteRequestedAt,
		&i.StorageShamanCheckoutID,
		&i.WorkerTagID,
	)
	return i, err
}

const fetchJobUUIDsUpdatedBefore = `-- name: FetchJobUUIDsUpdatedBefore :many
SELECT uuid FROM jobs WHERE updated_at <= ?1
`

func (q *Queries) FetchJobUUIDsUpdatedBefore(ctx context.Context, updatedAtMax sql.NullTime) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, fetchJobUUIDsUpdatedBefore, updatedAtMax)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var uuid string
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchJobsDeletionRequested = `-- name: FetchJobsDeletionRequested :many
SELECT uuid FROM jobs
  WHERE delete_requested_at is not NULL
  ORDER BY delete_requested_at
`

func (q *Queries) FetchJobsDeletionRequested(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, fetchJobsDeletionRequested)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var uuid string
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchJobsInStatus = `-- name: FetchJobsInStatus :many
SELECT id, created_at, updated_at, uuid, name, job_type, priority, status, activity, settings, metadata, delete_requested_at, storage_shaman_checkout_id, worker_tag_id FROM jobs WHERE status IN (/*SLICE:statuses*/?)
`

func (q *Queries) FetchJobsInStatus(ctx context.Context, statuses []string) ([]Job, error) {
	query := fetchJobsInStatus
	var queryParams []interface{}
	if len(statuses) > 0 {
		for _, v := range statuses {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:statuses*/?", strings.Repeat(",?", len(statuses))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:statuses*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UUID,
			&i.Name,
			&i.JobType,
			&i.Priority,
			&i.Status,
			&i.Activity,
			&i.Settings,
			&i.Metadata,
			&i.DeleteRequestedAt,
			&i.StorageShamanCheckoutID,
			&i.WorkerTagID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTask = `-- name: FetchTask :one
SELECT tasks.id, tasks.created_at, tasks.updated_at, tasks.uuid, tasks.name, tasks.type, tasks.job_id, tasks.priority, tasks.status, tasks.worker_id, tasks.last_touched_at, tasks.commands, tasks.activity, jobs.UUID as jobUUID, workers.UUID as workerUUID
FROM tasks
LEFT JOIN jobs ON (tasks.job_id = jobs.id)
LEFT JOIN workers ON (tasks.worker_id = workers.id)
WHERE tasks.uuid = ?1
`

type FetchTaskRow struct {
	Task       Task
	JobUUID    sql.NullString
	WorkerUUID sql.NullString
}

func (q *Queries) FetchTask(ctx context.Context, uuid string) (FetchTaskRow, error) {
	row := q.db.QueryRowContext(ctx, fetchTask, uuid)
	var i FetchTaskRow
	err := row.Scan(
		&i.Task.ID,
		&i.Task.CreatedAt,
		&i.Task.UpdatedAt,
		&i.Task.UUID,
		&i.Task.Name,
		&i.Task.Type,
		&i.Task.JobID,
		&i.Task.Priority,
		&i.Task.Status,
		&i.Task.WorkerID,
		&i.Task.LastTouchedAt,
		&i.Task.Commands,
		&i.Task.Activity,
		&i.JobUUID,
		&i.WorkerUUID,
	)
	return i, err
}

const fetchTaskJobUUID = `-- name: FetchTaskJobUUID :one
SELECT jobs.UUID as jobUUID
FROM tasks
LEFT JOIN jobs ON (tasks.job_id = jobs.id)
WHERE tasks.uuid = ?1
`

func (q *Queries) FetchTaskJobUUID(ctx context.Context, uuid string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, fetchTaskJobUUID, uuid)
	var jobuuid sql.NullString
	err := row.Scan(&jobuuid)
	return jobuuid, err
}

const fetchTasksOfJob = `-- name: FetchTasksOfJob :many
SELECT tasks.id, tasks.created_at, tasks.updated_at, tasks.uuid, tasks.name, tasks.type, tasks.job_id, tasks.priority, tasks.status, tasks.worker_id, tasks.last_touched_at, tasks.commands, tasks.activity, workers.UUID as workerUUID
FROM tasks
LEFT JOIN workers ON (tasks.worker_id = workers.id)
WHERE tasks.job_id = ?1
`

type FetchTasksOfJobRow struct {
	Task       Task
	WorkerUUID sql.NullString
}

func (q *Queries) FetchTasksOfJob(ctx context.Context, jobID int64) ([]FetchTasksOfJobRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchTasksOfJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchTasksOfJobRow
	for rows.Next() {
		var i FetchTasksOfJobRow
		if err := rows.Scan(
			&i.Task.ID,
			&i.Task.CreatedAt,
			&i.Task.UpdatedAt,
			&i.Task.UUID,
			&i.Task.Name,
			&i.Task.Type,
			&i.Task.JobID,
			&i.Task.Priority,
			&i.Task.Status,
			&i.Task.WorkerID,
			&i.Task.LastTouchedAt,
			&i.Task.Commands,
			&i.Task.Activity,
			&i.WorkerUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTasksOfJobInStatus = `-- name: FetchTasksOfJobInStatus :many
SELECT tasks.id, tasks.created_at, tasks.updated_at, tasks.uuid, tasks.name, tasks.type, tasks.job_id, tasks.priority, tasks.status, tasks.worker_id, tasks.last_touched_at, tasks.commands, tasks.activity, workers.UUID as workerUUID
FROM tasks
LEFT JOIN workers ON (tasks.worker_id = workers.id)
WHERE tasks.job_id = ?1
  AND tasks.status in (/*SLICE:task_status*/?)
`

type FetchTasksOfJobInStatusParams struct {
	JobID      int64
	TaskStatus []string
}

type FetchTasksOfJobInStatusRow struct {
	Task       Task
	WorkerUUID sql.NullString
}

func (q *Queries) FetchTasksOfJobInStatus(ctx context.Context, arg FetchTasksOfJobInStatusParams) ([]FetchTasksOfJobInStatusRow, error) {
	query := fetchTasksOfJobInStatus
	var queryParams []interface{}
	queryParams = append(queryParams, arg.JobID)
	if len(arg.TaskStatus) > 0 {
		for _, v := range arg.TaskStatus {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:task_status*/?", strings.Repeat(",?", len(arg.TaskStatus))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:task_status*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchTasksOfJobInStatusRow
	for rows.Next() {
		var i FetchTasksOfJobInStatusRow
		if err := rows.Scan(
			&i.Task.ID,
			&i.Task.CreatedAt,
			&i.Task.UpdatedAt,
			&i.Task.UUID,
			&i.Task.Name,
			&i.Task.Type,
			&i.Task.JobID,
			&i.Task.Priority,
			&i.Task.Status,
			&i.Task.WorkerID,
			&i.Task.LastTouchedAt,
			&i.Task.Commands,
			&i.Task.Activity,
			&i.WorkerUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTasksOfWorkerInStatus = `-- name: FetchTasksOfWorkerInStatus :many
SELECT tasks.id, tasks.created_at, tasks.updated_at, tasks.uuid, tasks.name, tasks.type, tasks.job_id, tasks.priority, tasks.status, tasks.worker_id, tasks.last_touched_at, tasks.commands, tasks.activity, jobs.UUID as jobUUID
FROM tasks
LEFT JOIN jobs ON (tasks.job_id = jobs.id)
WHERE tasks.worker_id = ?1
  AND tasks.status = ?2
`

type FetchTasksOfWorkerInStatusParams struct {
	WorkerID   sql.NullInt64
	TaskStatus string
}

type FetchTasksOfWorkerInStatusRow struct {
	Task    Task
	JobUUID sql.NullString
}

func (q *Queries) FetchTasksOfWorkerInStatus(ctx context.Context, arg FetchTasksOfWorkerInStatusParams) ([]FetchTasksOfWorkerInStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchTasksOfWorkerInStatus, arg.WorkerID, arg.TaskStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchTasksOfWorkerInStatusRow
	for rows.Next() {
		var i FetchTasksOfWorkerInStatusRow
		if err := rows.Scan(
			&i.Task.ID,
			&i.Task.CreatedAt,
			&i.Task.UpdatedAt,
			&i.Task.UUID,
			&i.Task.Name,
			&i.Task.Type,
			&i.Task.JobID,
			&i.Task.Priority,
			&i.Task.Status,
			&i.Task.WorkerID,
			&i.Task.LastTouchedAt,
			&i.Task.Commands,
			&i.Task.Activity,
			&i.JobUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTasksOfWorkerInStatusOfJob = `-- name: FetchTasksOfWorkerInStatusOfJob :many
SELECT tasks.id, tasks.created_at, tasks.updated_at, tasks.uuid, tasks.name, tasks.type, tasks.job_id, tasks.priority, tasks.status, tasks.worker_id, tasks.last_touched_at, tasks.commands, tasks.activity
FROM tasks
WHERE tasks.worker_id = ?1
  AND tasks.job_id = ?2
  AND tasks.status = ?3
`

type FetchTasksOfWorkerInStatusOfJobParams struct {
	WorkerID   sql.NullInt64
	JobID      int64
	TaskStatus string
}

type FetchTasksOfWorkerInStatusOfJobRow struct {
	Task Task
}

func (q *Queries) FetchTasksOfWorkerInStatusOfJob(ctx context.Context, arg FetchTasksOfWorkerInStatusOfJobParams) ([]FetchTasksOfWorkerInStatusOfJobRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchTasksOfWorkerInStatusOfJob, arg.WorkerID, arg.JobID, arg.TaskStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchTasksOfWorkerInStatusOfJobRow
	for rows.Next() {
		var i FetchTasksOfWorkerInStatusOfJobRow
		if err := rows.Scan(
			&i.Task.ID,
			&i.Task.CreatedAt,
			&i.Task.UpdatedAt,
			&i.Task.UUID,
			&i.Task.Name,
			&i.Task.Type,
			&i.Task.JobID,
			&i.Task.Priority,
			&i.Task.Status,
			&i.Task.WorkerID,
			&i.Task.LastTouchedAt,
			&i.Task.Commands,
			&i.Task.Activity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const jobCountTaskStatuses = `-- name: JobCountTaskStatuses :many
SELECT status, count(*) as num_tasks FROM tasks
WHERE job_id = ?1
GROUP BY status
`

type JobCountTaskStatusesRow struct {
	Status   string
	NumTasks int64
}

// Fetch (status, num tasks in that status) rows for the given job.
func (q *Queries) JobCountTaskStatuses(ctx context.Context, jobID int64) ([]JobCountTaskStatusesRow, error) {
	rows, err := q.db.QueryContext(ctx, jobCountTaskStatuses, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobCountTaskStatusesRow
	for rows.Next() {
		var i JobCountTaskStatusesRow
		if err := rows.Scan(&i.Status, &i.NumTasks); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const jobCountTasksInStatus = `-- name: JobCountTasksInStatus :one
SELECT count(*) as num_tasks FROM tasks
WHERE job_id = ?1 AND status = ?2
`

type JobCountTasksInStatusParams struct {
	JobID      int64
	TaskStatus string
}

// Fetch number of tasks in the given status, of the given job.
func (q *Queries) JobCountTasksInStatus(ctx context.Context, arg JobCountTasksInStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, jobCountTasksInStatus, arg.JobID, arg.TaskStatus)
	var num_tasks int64
	err := row.Scan(&num_tasks)
	return num_tasks, err
}

const requestJobDeletion = `-- name: RequestJobDeletion :exec
UPDATE jobs SET
  updated_at = ?1,
  delete_requested_at = ?1
WHERE id = ?2
`

type RequestJobDeletionParams struct {
	Now   sql.NullTime
	JobID int64
}

func (q *Queries) RequestJobDeletion(ctx context.Context, arg RequestJobDeletionParams) error {
	_, err := q.db.ExecContext(ctx, requestJobDeletion, arg.Now, arg.JobID)
	return err
}

const requestMassJobDeletion = `-- name: RequestMassJobDeletion :exec
UPDATE jobs SET
  updated_at = ?1,
  delete_requested_at = ?1
WHERE uuid in (/*SLICE:uuids*/?)
`

type RequestMassJobDeletionParams struct {
	Now   sql.NullTime
	UUIDs []string
}

func (q *Queries) RequestMassJobDeletion(ctx context.Context, arg RequestMassJobDeletionParams) error {
	query := requestMassJobDeletion
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Now)
	if len(arg.UUIDs) > 0 {
		for _, v := range arg.UUIDs {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:uuids*/?", strings.Repeat(",?", len(arg.UUIDs))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:uuids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const saveJobPriority = `-- name: SaveJobPriority :exec
UPDATE jobs SET updated_at=?1, priority=?2 WHERE id=?3
`

type SaveJobPriorityParams struct {
	Now      sql.NullTime
	Priority int64
	ID       int64
}

func (q *Queries) SaveJobPriority(ctx context.Context, arg SaveJobPriorityParams) error {
	_, err := q.db.ExecContext(ctx, saveJobPriority, arg.Now, arg.Priority, arg.ID)
	return err
}

const saveJobStatus = `-- name: SaveJobStatus :exec
UPDATE jobs SET updated_at=?1, status=?2, activity=?3 WHERE id=?4
`

type SaveJobStatusParams struct {
	Now      sql.NullTime
	Status   string
	Activity string
	ID       int64
}

func (q *Queries) SaveJobStatus(ctx context.Context, arg SaveJobStatusParams) error {
	_, err := q.db.ExecContext(ctx, saveJobStatus,
		arg.Now,
		arg.Status,
		arg.Activity,
		arg.ID,
	)
	return err
}

const saveJobStorageInfo = `-- name: SaveJobStorageInfo :exec
UPDATE jobs SET storage_shaman_checkout_id=?1 WHERE id=?2
`

type SaveJobStorageInfoParams struct {
	StorageShamanCheckoutID string
	ID                      int64
}

func (q *Queries) SaveJobStorageInfo(ctx context.Context, arg SaveJobStorageInfoParams) error {
	_, err := q.db.ExecContext(ctx, saveJobStorageInfo, arg.StorageShamanCheckoutID, arg.ID)
	return err
}

const taskAssignToWorker = `-- name: TaskAssignToWorker :exec
UPDATE tasks SET
  updated_at = ?1,
  worker_id = ?2
WHERE id=?3
`

type TaskAssignToWorkerParams struct {
	UpdatedAt sql.NullTime
	WorkerID  sql.NullInt64
	ID        int64
}

func (q *Queries) TaskAssignToWorker(ctx context.Context, arg TaskAssignToWorkerParams) error {
	_, err := q.db.ExecContext(ctx, taskAssignToWorker, arg.UpdatedAt, arg.WorkerID, arg.ID)
	return err
}

const updateTask = `-- name: UpdateTask :exec
UPDATE tasks SET
  updated_at = ?1,
  name = ?2,
  type = ?3,
  priority = ?4,
  status = ?5,
  worker_id = ?6,
  last_touched_at = ?7,
  commands = ?8,
  activity = ?9
WHERE id=?10
`

type UpdateTaskParams struct {
	UpdatedAt     sql.NullTime
	Name          string
	Type          string
	Priority      int64
	Status        string
	WorkerID      sql.NullInt64
	LastTouchedAt sql.NullTime
	Commands      json.RawMessage
	Activity      string
	ID            int64
}

// Update a Task, except its id, created_at, uuid, or job_id fields.
func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.db.ExecContext(ctx, updateTask,
		arg.UpdatedAt,
		arg.Name,
		arg.Type,
		arg.Priority,
		arg.Status,
		arg.WorkerID,
		arg.LastTouchedAt,
		arg.Commands,
		arg.Activity,
		arg.ID,
	)
	return err
}

const updateTaskActivity = `-- name: UpdateTaskActivity :exec
UPDATE tasks SET
  updated_at = ?1,
  activity = ?2
WHERE id=?3
`

type UpdateTaskActivityParams struct {
	UpdatedAt sql.NullTime
	Activity  string
	ID        int64
}

func (q *Queries) UpdateTaskActivity(ctx context.Context, arg UpdateTaskActivityParams) error {
	_, err := q.db.ExecContext(ctx, updateTaskActivity, arg.UpdatedAt, arg.Activity, arg.ID)
	return err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :exec
UPDATE tasks SET
  updated_at = ?1,
  status = ?2
WHERE id=?3
`

type UpdateTaskStatusParams struct {
	UpdatedAt sql.NullTime
	Status    string
	ID        int64
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTaskStatus, arg.UpdatedAt, arg.Status, arg.ID)
	return err
}
